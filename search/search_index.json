{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"olives-eda/","text":"EDA %matplotlib inline import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns pd.set_option('display.width', 500) pd.set_option('display.max_columns', 100) Italian Olives I found this data set in the RGGobi book (http://www.ggobi.org/book/), from which the above diagram is taken. It has \"the percentage composition of fatty acids found in the lipid fraction of Italian olive oils', with oils from 3 regions of Italy: the North, the South, and Sardinia. The regions themselves are subdivided into areas as shown in the map above. The source for this data is: Forina, M., Armanino, C., Lanteri, S. & Tiscornia, E. (1983), Classification of Olive Oils from their Fatty Acid Composition, in Martens, H. and Russwurm Jr., H., eds, Food Research and Data Analysis, Applied Science Publishers, London, pp. 189\u2013214. Exploratory Viz df = pd.read_csv(\"local-olives-cleaned.csv\") df.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South exploring globally pd.crosstab(df.areastring, df.regionstring) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } regionstring North Sardinia South areastring Calabria 0 0 56 Coast-Sardinia 0 33 0 East-Liguria 50 0 0 Inland-Sardinia 0 65 0 North-Apulia 0 0 25 Sicily 0 0 36 South-Apulia 0 0 206 Umbria 51 0 0 West-Liguria 50 0 0 pd.value_counts(df.areastring, sort=False).plot(kind=\"bar\"); pd.value_counts(df.regionstring, sort=False).plot(kind=\"barh\"); acidlist=['palmitic', 'palmitoleic', 'stearic', 'oleic', 'linoleic', 'linolenic', 'arachidic', 'eicosenoic'] df[acidlist].median().plot(kind=\"bar\"); Or one can use aggregate to pass an arbitrary function of to the sub-dataframe. The function is applied columnwise. dfbymean=df.groupby(\"regionstring\").aggregate(np.mean) dfbymean.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring North 3.0 8.006623 10.948013 0.837351 2.308013 77.930530 7.270331 0.217881 0.375762 0.019735 Sardinia 2.0 5.336735 11.113469 0.967449 2.261837 72.680204 11.965306 0.270918 0.731735 0.019388 South 1.0 2.783282 13.322879 1.548019 2.287740 71.000093 10.334985 0.380650 0.631176 0.273220 with sns.axes_style(\"white\", {'grid':False}): dfbymean[acidlist].plot(kind='barh', stacked=True); sns.despine() Figuring the dataset by Region g=sns.FacetGrid(df, col=\"region\") g.map(plt.scatter,\"eicosenoic\", \"linoleic\"); Clearly, region 1 or the South can visually be separated out by eicosenoic fraction itself. with sns.axes_style(\"white\"): g=sns.FacetGrid(df, col=\"region\") g.map(sns.distplot, \"eicosenoic\") We make a SPLOM using seaborn to see in what space the regions may be separated. Note that linoleic and oleic seem promising. And perhaps arachidic paired with eicosenoic. sns.pairplot(df, vars=acidlist, hue=\"regionstring\", size=2.5, diag_kind='kde'); Pandas supports conditional indexing: documentation . Lets use it to follow up on the clear pattern of Southern oils seeeming to be separable by just the eicosenoic feature. Indeed this is the case! Can also be seen using parallel co-ordinates: from pandas.tools.plotting import parallel_coordinates dfna=df[acidlist] #normalizing by range dfna_norm = (dfna - dfna.mean()) / (dfna.max() - dfna.min()) with sns.axes_style(\"white\"): parallel_coordinates(df[['regionstring']].join(dfna_norm), 'regionstring', alpha=0.3) Figuring the South of Italy by Area dfsouth=df[df.regionstring=='South'] dfsouth.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South We make a couple of SPLOM's, one with sicily and one without sicily, to see whats separable. Sicily seems to be a problem. As before, see the KDE's first to see if separability exists and then let the eye look for patterns. sns.pairplot(dfsouth, hue=\"areastring\", size=2.5, vars=acidlist, diag_kind='kde'); sns.pairplot(dfsouth[dfsouth.areastring!=\"Sicily\"], hue=\"areastring\", size=2.5, vars=acidlist, diag_kind='kde'); Seems that combinations of oleic, palmitic, palmitoleic might be useful?","title":"EDA"},{"location":"olives-eda/#eda","text":"%matplotlib inline import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns pd.set_option('display.width', 500) pd.set_option('display.max_columns', 100)","title":"EDA"},{"location":"olives-eda/#italian-olives","text":"I found this data set in the RGGobi book (http://www.ggobi.org/book/), from which the above diagram is taken. It has \"the percentage composition of fatty acids found in the lipid fraction of Italian olive oils', with oils from 3 regions of Italy: the North, the South, and Sardinia. The regions themselves are subdivided into areas as shown in the map above. The source for this data is: Forina, M., Armanino, C., Lanteri, S. & Tiscornia, E. (1983), Classification of Olive Oils from their Fatty Acid Composition, in Martens, H. and Russwurm Jr., H., eds, Food Research and Data Analysis, Applied Science Publishers, London, pp. 189\u2013214.","title":"Italian Olives"},{"location":"olives-eda/#exploratory-viz","text":"df = pd.read_csv(\"local-olives-cleaned.csv\") df.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South","title":"Exploratory Viz"},{"location":"olives-eda/#exploring-globally","text":"pd.crosstab(df.areastring, df.regionstring) .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } regionstring North Sardinia South areastring Calabria 0 0 56 Coast-Sardinia 0 33 0 East-Liguria 50 0 0 Inland-Sardinia 0 65 0 North-Apulia 0 0 25 Sicily 0 0 36 South-Apulia 0 0 206 Umbria 51 0 0 West-Liguria 50 0 0 pd.value_counts(df.areastring, sort=False).plot(kind=\"bar\"); pd.value_counts(df.regionstring, sort=False).plot(kind=\"barh\"); acidlist=['palmitic', 'palmitoleic', 'stearic', 'oleic', 'linoleic', 'linolenic', 'arachidic', 'eicosenoic'] df[acidlist].median().plot(kind=\"bar\"); Or one can use aggregate to pass an arbitrary function of to the sub-dataframe. The function is applied columnwise. dfbymean=df.groupby(\"regionstring\").aggregate(np.mean) dfbymean.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring North 3.0 8.006623 10.948013 0.837351 2.308013 77.930530 7.270331 0.217881 0.375762 0.019735 Sardinia 2.0 5.336735 11.113469 0.967449 2.261837 72.680204 11.965306 0.270918 0.731735 0.019388 South 1.0 2.783282 13.322879 1.548019 2.287740 71.000093 10.334985 0.380650 0.631176 0.273220 with sns.axes_style(\"white\", {'grid':False}): dfbymean[acidlist].plot(kind='barh', stacked=True); sns.despine()","title":"exploring globally"},{"location":"olives-eda/#figuring-the-dataset-by-region","text":"g=sns.FacetGrid(df, col=\"region\") g.map(plt.scatter,\"eicosenoic\", \"linoleic\"); Clearly, region 1 or the South can visually be separated out by eicosenoic fraction itself. with sns.axes_style(\"white\"): g=sns.FacetGrid(df, col=\"region\") g.map(sns.distplot, \"eicosenoic\") We make a SPLOM using seaborn to see in what space the regions may be separated. Note that linoleic and oleic seem promising. And perhaps arachidic paired with eicosenoic. sns.pairplot(df, vars=acidlist, hue=\"regionstring\", size=2.5, diag_kind='kde'); Pandas supports conditional indexing: documentation . Lets use it to follow up on the clear pattern of Southern oils seeeming to be separable by just the eicosenoic feature. Indeed this is the case! Can also be seen using parallel co-ordinates: from pandas.tools.plotting import parallel_coordinates dfna=df[acidlist] #normalizing by range dfna_norm = (dfna - dfna.mean()) / (dfna.max() - dfna.min()) with sns.axes_style(\"white\"): parallel_coordinates(df[['regionstring']].join(dfna_norm), 'regionstring', alpha=0.3)","title":"Figuring the dataset by Region"},{"location":"olives-eda/#figuring-the-south-of-italy-by-area","text":"dfsouth=df[df.regionstring=='South'] dfsouth.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South We make a couple of SPLOM's, one with sicily and one without sicily, to see whats separable. Sicily seems to be a problem. As before, see the KDE's first to see if separability exists and then let the eye look for patterns. sns.pairplot(dfsouth, hue=\"areastring\", size=2.5, vars=acidlist, diag_kind='kde'); sns.pairplot(dfsouth[dfsouth.areastring!=\"Sicily\"], hue=\"areastring\", size=2.5, vars=acidlist, diag_kind='kde'); Seems that combinations of oleic, palmitic, palmitoleic might be useful?","title":"Figuring the South of Italy by Area"},{"location":"olives-model/","text":"Models #!pip install seaborn %matplotlib inline import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns pd.set_option('display.width', 500) pd.set_option('display.max_columns', 100) df = pd.read_csv(\"local-olives-cleaned.csv\") df.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South acidlist=['palmitic', 'palmitoleic', 'stearic', 'oleic', 'linoleic', 'linolenic', 'arachidic', 'eicosenoic'] dfsouth=df[df.regionstring=='South'] dfsouth.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South Predicting via SVM dfnew=df[['eicosenoic', 'region', 'regionstring']] dfnew['linoarch']=(0.969/1022.0)*df.linoleic + (0.245/105.0)*df.arachidic dfnew.head() eicosenoic region regionstring linoarch 0 0.29 1 South 0.007772 1 0.29 1 South 0.008828 2 0.29 1 South 0.006675 3 0.35 1 South 0.007689 4 0.46 1 South 0.008238 dfnosouth=df[df.regionstring!='South'] dfnosouth.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 323 Inland-Sardinia 2 5 11.29 1.20 2.22 72.72 11.12 0.43 0.98 0.02 Sardinia 324 Inland-Sardinia 2 5 10.42 1.35 2.10 73.76 11.16 0.35 0.90 0.03 Sardinia 325 Inland-Sardinia 2 5 11.03 0.96 2.10 73.80 10.85 0.32 0.94 0.03 Sardinia 326 Inland-Sardinia 2 5 11.18 0.97 2.21 72.79 11.54 0.35 0.94 0.02 Sardinia 327 Inland-Sardinia 2 5 10.52 0.95 2.15 73.88 11.26 0.31 0.92 0.01 Sardinia plt.scatter(dfnosouth.linoleic, dfnosouth.arachidic, c=dfnosouth.region, s=50); from sklearn.cross_validation import train_test_split from sklearn.metrics import confusion_matrix from sklearn.svm import SVC # \"Support Vector Classifier\" def plot_svc_decision_function(clf, ax=None): \"\"\"Plot the decision function for a 2D SVC\"\"\" if ax is None: ax = plt.gca() x = np.linspace(plt.xlim()[0], plt.xlim()[1], 30) y = np.linspace(plt.ylim()[0], plt.ylim()[1], 30) Y, X = np.meshgrid(y, x) P = np.zeros_like(X) for i, xi in enumerate(x): for j, yj in enumerate(y): P[i, j] = clf.decision_function([[xi, yj]]) return ax.contour(X, Y, P, colors='k', levels=[-1, 0, 1], alpha=0.5, linestyles=['--', '-', '--']) X = dfnosouth[['linoleic', 'arachidic']] y = (dfnosouth.regionstring.values=='Sardinia')*1 Xtrain, Xtest, ytrain, ytest = train_test_split(X.values ,y) clf = SVC(kernel=\"linear\") clf.fit(Xtrain, ytrain) plt.scatter(Xtrain[:, 0], Xtrain[:, 1], c=ytrain, s=50, cmap='spring', alpha=0.3) plot_svc_decision_function(clf, plt.gca()) plt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1], s=200, facecolors='none') plt.scatter(Xtest[:, 0], Xtest[:, 1], c=ytest, s=50, marker=\"s\", cmap='spring', alpha=0.5); clf.score(Xtest, ytest) 1.0 confusion_matrix(clf.predict(Xtest), ytest) array([[31, 0], [ 0, 32]]) Allowing for crossovers from sklearn.model_selection import GridSearchCV def cv_optimize_svm(X, y, n_folds=10, num_p=50): #clf = SVC() #parameters = {\"C\": np.logspace(-4, 3, num=num_p), \"gamma\": np.logspace(-4, 3, num=10)} clf = SVC(kernel=\"linear\", probability=True) parameters = {\"C\": np.logspace(-4, 3, num=num_p)} gs = GridSearchCV(clf, param_grid=parameters, cv=n_folds) gs.fit(X, y) return gs def get_optim_classifier_svm(indf, inacidlist, clon, clonval): subdf=indf[inacidlist] subdfstd=(subdf - subdf.mean())/subdf.std() X=subdfstd.values y=(indf[clon].values==clonval)*1 Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, train_size=0.8) #Xtrain, Xtest, ytrain, ytest=X,X,y,y fitted=cv_optimize_svm(Xtrain, ytrain) return fitted, Xtrain, ytrain, Xtest, ytest thesvcfit, Xtr, ytr, Xte, yte = get_optim_classifier_svm(dfnosouth, ['linoleic','arachidic'],'regionstring', \"Sardinia\") #thesvcfit, Xtr, ytr, Xte, yte = get_optim_classifier_binary(dfsouthns, ['palmitic','palmitoleic'],'area', 3) thesvcfit.best_estimator_, thesvcfit.best_params_, thesvcfit.best_score_ (SVC(C=0.071968567300115138, cache_size=200, class_weight=None, coef0=0.0, decision_function_shape=None, degree=3, gamma='auto', kernel='linear', max_iter=-1, probability=True, random_state=None, shrinking=True, tol=0.001, verbose=False), {'C': 0.071968567300115138}, 1.0) def plot_svm_new(clf,Xtr,ytr,Xte,yte): plt.scatter(Xtr[:, 0], Xtr[:, 1], c=ytr, s=50, cmap='spring', alpha=0.5) plt.scatter(Xte[:, 0], Xte[:, 1], marker='s', c=yte, s=50, cmap='spring', alpha=0.5) #plt.xlim(-1, 4) #plt.ylim(-1, 6) plot_svc_decision_function(clf, plt.gca()) plt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1], s=100, facecolors=None , lw=2, alpha=0.4) print(dict(kernel=\"linear\",**thesvcfit.best_params_)) clsvc=SVC(**dict(kernel=\"linear\",**thesvcfit.best_params_)).fit(Xtr, ytr) plot_svm_new(clsvc, Xtr, ytr, Xte, yte) {'kernel': 'linear', 'C': 0.071968567300115138} The best fit allows for a bigger margin by allowing some inbetween penalization. If we use the standard C=1 in scikit-learn you see that we are allowing for less penalization.","title":"MODEL"},{"location":"olives-model/#models","text":"#!pip install seaborn %matplotlib inline import numpy as np import matplotlib.pyplot as plt import pandas as pd import seaborn as sns pd.set_option('display.width', 500) pd.set_option('display.max_columns', 100) df = pd.read_csv(\"local-olives-cleaned.csv\") df.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South acidlist=['palmitic', 'palmitoleic', 'stearic', 'oleic', 'linoleic', 'linolenic', 'arachidic', 'eicosenoic'] dfsouth=df[df.regionstring=='South'] dfsouth.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 0 North-Apulia 1 1 10.75 0.75 2.26 78.23 6.72 0.36 0.60 0.29 South 1 North-Apulia 1 1 10.88 0.73 2.24 77.09 7.81 0.31 0.61 0.29 South 2 North-Apulia 1 1 9.11 0.54 2.46 81.13 5.49 0.31 0.63 0.29 South 3 North-Apulia 1 1 9.66 0.57 2.40 79.52 6.19 0.50 0.78 0.35 South 4 North-Apulia 1 1 10.51 0.67 2.59 77.71 6.72 0.50 0.80 0.46 South","title":"Models"},{"location":"olives-model/#predicting-via-svm","text":"dfnew=df[['eicosenoic', 'region', 'regionstring']] dfnew['linoarch']=(0.969/1022.0)*df.linoleic + (0.245/105.0)*df.arachidic dfnew.head() eicosenoic region regionstring linoarch 0 0.29 1 South 0.007772 1 0.29 1 South 0.008828 2 0.29 1 South 0.006675 3 0.35 1 South 0.007689 4 0.46 1 South 0.008238 dfnosouth=df[df.regionstring!='South'] dfnosouth.head() .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; } areastring region area palmitic palmitoleic stearic oleic linoleic linolenic arachidic eicosenoic regionstring 323 Inland-Sardinia 2 5 11.29 1.20 2.22 72.72 11.12 0.43 0.98 0.02 Sardinia 324 Inland-Sardinia 2 5 10.42 1.35 2.10 73.76 11.16 0.35 0.90 0.03 Sardinia 325 Inland-Sardinia 2 5 11.03 0.96 2.10 73.80 10.85 0.32 0.94 0.03 Sardinia 326 Inland-Sardinia 2 5 11.18 0.97 2.21 72.79 11.54 0.35 0.94 0.02 Sardinia 327 Inland-Sardinia 2 5 10.52 0.95 2.15 73.88 11.26 0.31 0.92 0.01 Sardinia plt.scatter(dfnosouth.linoleic, dfnosouth.arachidic, c=dfnosouth.region, s=50); from sklearn.cross_validation import train_test_split from sklearn.metrics import confusion_matrix from sklearn.svm import SVC # \"Support Vector Classifier\" def plot_svc_decision_function(clf, ax=None): \"\"\"Plot the decision function for a 2D SVC\"\"\" if ax is None: ax = plt.gca() x = np.linspace(plt.xlim()[0], plt.xlim()[1], 30) y = np.linspace(plt.ylim()[0], plt.ylim()[1], 30) Y, X = np.meshgrid(y, x) P = np.zeros_like(X) for i, xi in enumerate(x): for j, yj in enumerate(y): P[i, j] = clf.decision_function([[xi, yj]]) return ax.contour(X, Y, P, colors='k', levels=[-1, 0, 1], alpha=0.5, linestyles=['--', '-', '--']) X = dfnosouth[['linoleic', 'arachidic']] y = (dfnosouth.regionstring.values=='Sardinia')*1 Xtrain, Xtest, ytrain, ytest = train_test_split(X.values ,y) clf = SVC(kernel=\"linear\") clf.fit(Xtrain, ytrain) plt.scatter(Xtrain[:, 0], Xtrain[:, 1], c=ytrain, s=50, cmap='spring', alpha=0.3) plot_svc_decision_function(clf, plt.gca()) plt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1], s=200, facecolors='none') plt.scatter(Xtest[:, 0], Xtest[:, 1], c=ytest, s=50, marker=\"s\", cmap='spring', alpha=0.5); clf.score(Xtest, ytest) 1.0 confusion_matrix(clf.predict(Xtest), ytest) array([[31, 0], [ 0, 32]])","title":"Predicting via SVM"},{"location":"olives-model/#allowing-for-crossovers","text":"from sklearn.model_selection import GridSearchCV def cv_optimize_svm(X, y, n_folds=10, num_p=50): #clf = SVC() #parameters = {\"C\": np.logspace(-4, 3, num=num_p), \"gamma\": np.logspace(-4, 3, num=10)} clf = SVC(kernel=\"linear\", probability=True) parameters = {\"C\": np.logspace(-4, 3, num=num_p)} gs = GridSearchCV(clf, param_grid=parameters, cv=n_folds) gs.fit(X, y) return gs def get_optim_classifier_svm(indf, inacidlist, clon, clonval): subdf=indf[inacidlist] subdfstd=(subdf - subdf.mean())/subdf.std() X=subdfstd.values y=(indf[clon].values==clonval)*1 Xtrain, Xtest, ytrain, ytest = train_test_split(X, y, train_size=0.8) #Xtrain, Xtest, ytrain, ytest=X,X,y,y fitted=cv_optimize_svm(Xtrain, ytrain) return fitted, Xtrain, ytrain, Xtest, ytest thesvcfit, Xtr, ytr, Xte, yte = get_optim_classifier_svm(dfnosouth, ['linoleic','arachidic'],'regionstring', \"Sardinia\") #thesvcfit, Xtr, ytr, Xte, yte = get_optim_classifier_binary(dfsouthns, ['palmitic','palmitoleic'],'area', 3) thesvcfit.best_estimator_, thesvcfit.best_params_, thesvcfit.best_score_ (SVC(C=0.071968567300115138, cache_size=200, class_weight=None, coef0=0.0, decision_function_shape=None, degree=3, gamma='auto', kernel='linear', max_iter=-1, probability=True, random_state=None, shrinking=True, tol=0.001, verbose=False), {'C': 0.071968567300115138}, 1.0) def plot_svm_new(clf,Xtr,ytr,Xte,yte): plt.scatter(Xtr[:, 0], Xtr[:, 1], c=ytr, s=50, cmap='spring', alpha=0.5) plt.scatter(Xte[:, 0], Xte[:, 1], marker='s', c=yte, s=50, cmap='spring', alpha=0.5) #plt.xlim(-1, 4) #plt.ylim(-1, 6) plot_svc_decision_function(clf, plt.gca()) plt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1], s=100, facecolors=None , lw=2, alpha=0.4) print(dict(kernel=\"linear\",**thesvcfit.best_params_)) clsvc=SVC(**dict(kernel=\"linear\",**thesvcfit.best_params_)).fit(Xtr, ytr) plot_svm_new(clsvc, Xtr, ytr, Xte, yte) {'kernel': 'linear', 'C': 0.071968567300115138} The best fit allows for a bigger margin by allowing some inbetween penalization. If we use the standard C=1 in scikit-learn you see that we are allowing for less penalization.","title":"Allowing for crossovers"}]}